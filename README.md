# cpp-review-7

Scope is where identifiers can be accessed (in scope if it can be/out of scope if it can't), linkage is whether declaration of same identifier in different scope refers to same object/function (has linkage if so/doesn't if not)
Compound statement/block is group of statements treated by compiler as single statement, enclosed in brackets, can be nested
Use :: to access things in namespaces, can define namespace to create different contexts for program, using :: without namespace name uses global namespace, can use forward declarations within namespace, can use namespace declarations across multiple files (headers or regular files)/all considered part of same namespace, can also nest namespaces with outer::inner::, can make alias for namesapce with namespace alias = name, use for any code distributed to others to prevent conflicts (usually single top level namespace enough, 2/3 levels for multiple teams)
Local variables have scope until end of block they're declared in (after that destroyed), all variable names declared in scope must be unique, also have no linkage, limit scope of local variables to block they're used in
Global variables declared at top of file in global namespace, are visible from point of declaration until end of file, can also be defined in user namespace, have static duration (created when program starts before main() execution/destroyed when it ends, static variables), can use g_ to indicate if desired, should generally make const
Shadowing is when local variable from outer block is hidden due to local variable from inner block having same name, can also do with global variable/local variable, should avoid since it can lead to errors
Global variables/function identifiers have either internal or external linkage, internal linkage identifier can be seen/used within single translation unit (source file after preprocessing used to make object file) but not others (so 2 source files with same identifier name treat identifiers as independent), external linkage identifier can be seen/used within multiple translation units
Internal linkage can be specified for global variables with static keyword
(non-const global variables have external linkage by default, const/constexpr global variables have internal linkage by default)
Functions default to external linkage (reason why forward declarations work), can be set to internal linkage with static keyword (internal linkage function must be defined within file)
Internal linkage used to make sure identifier isn't accessible to other files/avoid naming collisions in linker
Global variable with external linkage called external variable, use extern keyword to give external linkage (use for const/constexpr global variables to make them external), need to use forward declaration for external variables to be used in additional files (don't need for functions)
Non-const global variables should be avoided since their value can be changed at any point in files, easier for errors to appear (not initialized yet, etc.), only use if only one of thing will exist/is ubiquitous throughout program (ex. log file, random number generator), should encapsulate interally/access through external functions
To share global constants across multiple files can define them all in header file (means variables will be copied into every file that uses header, uses space), can also define constants as external variables in cpp file/use forward declaration in header file (links all header inclusions to single variable instantiation in cpp file, only cpp file recompiled if change made means constexpr will be treated as runtime constant instead of compile time const), can also define variables inline in header file (only instantiated once/maintains constexpr, means every file must be recompiled if change made)
Static has several meanings, can refer to static duration (created when program starts/destroyed when program ends), static referring to global variable (internal linkage, identifier can only be used in file where it's defined), static referring to local variable (changes duration from automatic to static, variable is now created at start of program/destroyed at end of program, keeps value even after going out of scope, get zero initialization at program start if initializer non-constexpr/reinitialized at variable definition, simply goes out of scope after block ends without destruction, useful for unique ID generation, can create const static local variables for function that needs const value for object that's expensive to initialize, don't use to alter program flow with control statements)
Qualified name includes associated scope (ex. namespace or class from scope resolution operator, std::cout), unqualified name doesn't (ex. cout)
Using declaration lets us use unqualified name as alias for qualified name, 
ex. using std::cout tells compiler we're using object cout from std namespace, helpful if you're using cout many times (can put in function, don't use in namespace/global namespace of header file)
Using directive allows all identfiers in namespace to be referenced without qualification within scope, ex. using namespace std tells compiler that all names in std namespace should be accessible without qualification (not much benefit to use today, shouldn't give unqualified access to all names in namespace, chance of naming collisions/other errors)
Using declaration/directive has scope within block if defined in block, file scope if defined globally
Unnamed namespace defined without name, treated as part of parent namespace (global namespace if no parent), all identifiers within treated as having internal linkage (content of unnamed namespace can't be seen outside of file, useful when a lot of content needs to stay local to file)
Inline namespace also considered part of parent namespace, unlike unnamed namespace doesn't affect linkage, useful for versioning since calls without namespace default to parent version, preserves functionality while still allowing newer versions, can nest inline namespace in unnamed namespace
